


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Schema</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.everit.json.schema</a>
</div>

<h1>Coverage Summary for Class: Schema (org.everit.json.schema)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Schema</td>
<td class="coverageStat">
  <span class="percent">
    87%
  </span>
  <span class="absValue">
    (20/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (18/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (52/56)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Schema$Builder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (24/24)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    91.2%
  </span>
  <span class="absValue">
    (31/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (18/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (76/80)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.everit.json.schema;
&nbsp;
&nbsp;import static java.util.Collections.unmodifiableMap;
&nbsp;
&nbsp;import java.io.StringWriter;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;import org.everit.json.schema.internal.JSONPrinter;
&nbsp;import org.json.JSONWriter;
&nbsp;
&nbsp;/**
&nbsp; * Superclass of all other schema validator classes of this package.
&nbsp; */
&nbsp;public abstract class Schema {
&nbsp;
&nbsp;    /**
&nbsp;     * Abstract builder class for the builder classes of {@code Schema} subclasses. This builder is
&nbsp;     * used to load the generic properties of all types of schemas like {@code title} or
&nbsp;     * {@code description}.
&nbsp;     *
&nbsp;     * @param &lt;S&gt;
&nbsp;     *         the type of the schema being built by the builder subclass.
&nbsp;     */
<b class="fc">&nbsp;    public abstract static class Builder&lt;S extends Schema&gt; {</b>
&nbsp;
&nbsp;        private String title;
&nbsp;
&nbsp;        private String description;
&nbsp;
&nbsp;        private String id;
&nbsp;
&nbsp;        private SchemaLocation schemaLocation;
&nbsp;
&nbsp;        private Object defaultValue;
&nbsp;
<b class="fc">&nbsp;        private Boolean nullable = null;</b>
&nbsp;
<b class="fc">&nbsp;        private Boolean readOnly = null;</b>
&nbsp;
<b class="fc">&nbsp;        private Boolean writeOnly = null;</b>
&nbsp;
<b class="fc">&nbsp;        public Map&lt;String, Object&gt; unprocessedProperties = new HashMap&lt;&gt;(0);</b>
&nbsp;
&nbsp;        public Builder&lt;S&gt; title(String title) {
<b class="fc">&nbsp;            this.title = title;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; description(String description) {
<b class="fc">&nbsp;            this.description = description;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; id(String id) {
<b class="fc">&nbsp;            this.id = id;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated Use {@link #schemaLocation(SchemaLocation)} instead.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public Builder&lt;S&gt; schemaLocation(String schemaLocation) {
<b class="fc">&nbsp;            return schemaLocation(SchemaLocation.parseURI(schemaLocation));</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; schemaLocation(SchemaLocation location) {
<b class="fc">&nbsp;            this.schemaLocation = location;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; defaultValue(Object defaultValue) {
<b class="fc">&nbsp;            this.defaultValue = defaultValue;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; nullable(Boolean nullable) {
<b class="fc">&nbsp;            this.nullable = nullable;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; readOnly(Boolean readOnly) {
<b class="fc">&nbsp;            this.readOnly = readOnly;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; writeOnly(Boolean writeOnly) {
<b class="fc">&nbsp;            this.writeOnly = writeOnly;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder&lt;S&gt; unprocessedProperties(Map&lt;String, Object&gt; unprocessedProperties) {
<b class="fc">&nbsp;            this.unprocessedProperties = unprocessedProperties;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public abstract S build();
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private final String title;
&nbsp;
&nbsp;    private final String description;
&nbsp;
&nbsp;    private final String id;
&nbsp;
&nbsp;    @Deprecated
&nbsp;    protected final String schemaLocation;
&nbsp;
&nbsp;    private final SchemaLocation location;
&nbsp;
&nbsp;    private final Object defaultValue;
&nbsp;
&nbsp;    private final Boolean nullable;
&nbsp;
&nbsp;    private final Boolean readOnly;
&nbsp;
&nbsp;    private final Boolean writeOnly;
&nbsp;
&nbsp;    private final Map&lt;String, Object&gt; unprocessedProperties;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor.
&nbsp;     *
&nbsp;     * @param builder
&nbsp;     *         the builder containing the optional title, description and id attributes of the schema
&nbsp;     */
<b class="fc">&nbsp;    protected Schema(Builder&lt;?&gt; builder) {</b>
<b class="fc">&nbsp;        this.title = builder.title;</b>
<b class="fc">&nbsp;        this.description = builder.description;</b>
<b class="fc">&nbsp;        this.id = builder.id;</b>
<b class="fc">&nbsp;        this.schemaLocation = builder.schemaLocation == null ? null : builder.schemaLocation.toString();</b>
<b class="fc">&nbsp;        this.location = builder.schemaLocation;</b>
<b class="fc">&nbsp;        this.defaultValue = builder.defaultValue;</b>
<b class="fc">&nbsp;        this.nullable = builder.nullable;</b>
<b class="fc">&nbsp;        this.readOnly = builder.readOnly;</b>
<b class="fc">&nbsp;        this.writeOnly = builder.writeOnly;</b>
<b class="fc">&nbsp;        this.unprocessedProperties = new HashMap&lt;&gt;(builder.unprocessedProperties);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the schema validation.
&nbsp;     *
&nbsp;     * @param subject
&nbsp;     *         the object to be validated
&nbsp;     * @throws ValidationException
&nbsp;     *         if the {@code subject} is invalid against this schema.
&nbsp;     */
&nbsp;    public void validate(Object subject) {
<b class="fc">&nbsp;        Validator.builder().build().performValidation(this, subject);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if this {@code Schema} instance defines any restrictions for the object property
&nbsp;     * denoted by {@code field}. The {@code field} should be a JSON pointer, denoting the property to
&nbsp;     * be queried.
&nbsp;     * &lt;p&gt;
&nbsp;     * For example the field {@code &quot;#/rectangle/a&quot;} is defined by the following schema:
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;pre&gt;
&nbsp;     * &lt;code&gt;
&nbsp;     * objectWithSchemaRectangleDep&quot; : {
&nbsp;     *   &quot;type&quot; : &quot;object&quot;,
&nbsp;     *   &quot;dependencies&quot; : {
&nbsp;     *       &quot;d&quot; : {
&nbsp;     *           &quot;type&quot; : &quot;object&quot;,
&nbsp;     *           &quot;properties&quot; : {
&nbsp;     *               &quot;rectangle&quot; : {
&nbsp;     *                  &quot;$ref&quot; : &quot;#/definitions/Rectangle&quot;
&nbsp;     *               },
&nbsp;     *               &quot;list&quot;: {
&nbsp;     *                   &quot;type&quot;: &quot;array&quot;,
&nbsp;     *                   &quot;items&quot;: {
&nbsp;     *                       &quot;properties&quot;: {
&nbsp;     *                          &quot;prop&quot;: {}
&nbsp;     *                       }
&nbsp;     *                   },
&nbsp;     *                   &quot;minItems&quot;: 2,
&nbsp;     *                   &quot;maxItems: 3
&nbsp;     *               }
&nbsp;     *           }
&nbsp;     *       }
&nbsp;     *   },
&nbsp;     *   &quot;definitions&quot; : {
&nbsp;     *       &quot;size&quot; : {
&nbsp;     *           &quot;type&quot; : &quot;number&quot;,
&nbsp;     *           &quot;minimum&quot; : 0
&nbsp;     *       },
&nbsp;     *       &quot;Rectangle&quot; : {
&nbsp;     *           &quot;type&quot; : &quot;object&quot;,
&nbsp;     *           &quot;properties&quot; : {
&nbsp;     *               &quot;a&quot; : {&quot;$ref&quot; : &quot;#/definitions/size&quot;},
&nbsp;     *               &quot;b&quot; : {&quot;$ref&quot; : &quot;#/definitions/size&quot;}
&nbsp;     *           }
&nbsp;     *       }
&nbsp;     *    }
&nbsp;     * }
&nbsp;     * &lt;/code&gt;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * You can also check if a subschema of an array defines a property. In that case, to traverse the array, you can either use
&nbsp;     * an integer array index, or the {@code &quot;all&quot;} or {@code &quot;any&quot;} meta-indexes. For example, in the above schema
&nbsp;     * &lt;ul&gt;
&nbsp;     *     &lt;li&gt;{@code definesProperty(&quot;#/list/any/prop&quot;)} returns {@code true}&lt;/li&gt;
&nbsp;     *     &lt;li&gt;{@code definesProperty(&quot;#/list/all/prop&quot;)} returns {@code true}&lt;/li&gt;
&nbsp;     *     &lt;li&gt;{@code definesProperty(&quot;#/list/1/prop&quot;)} returns {@code true}&lt;/li&gt;
&nbsp;     *     &lt;li&gt;{@code definesProperty(&quot;#/list/1/nonexistent&quot;)} returns {@code false} (the property is not present in the
&nbsp;     *     subschema)&lt;/li&gt;
&nbsp;     *     &lt;li&gt;{@code definesProperty(&quot;#/list/8/prop&quot;)} returns {@code false} (the {@code &quot;list&quot;} does not define
&nbsp;     *     property {@code 8}, since {@code &quot;maxItems&quot;} is {@code 3})&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * The default implementation of this method always returns false.
&nbsp;     *
&nbsp;     * @param field
&nbsp;     *         should be a JSON pointer in its string representation.
&nbsp;     * @return {@code true} if the propertty denoted by {@code field} is defined by this schema
&nbsp;     * instance
&nbsp;     */
&nbsp;    public boolean definesProperty(String field) {
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shared method for {@link #definesProperty(String)} implementations.
&nbsp;     *
&nbsp;     * @param pointer
&nbsp;     * @return
&nbsp;     */
&nbsp;    String[] headAndTailOfJsonPointerFragment(String pointer) {
<b class="fc">&nbsp;        String field = pointer.replaceFirst(&quot;^#&quot;, &quot;&quot;).replaceFirst(&quot;^/&quot;, &quot;&quot;);</b>
<b class="fc">&nbsp;        int firstSlashIdx = field.indexOf(&#39;/&#39;);</b>
&nbsp;        String nextToken, remaining;
<b class="fc">&nbsp;        if (firstSlashIdx == -1) {</b>
<b class="fc">&nbsp;            nextToken = field;</b>
<b class="fc">&nbsp;            remaining = null;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            nextToken = field.substring(0, firstSlashIdx);</b>
<b class="fc">&nbsp;            remaining = field.substring(firstSlashIdx + 1);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new String[]{nextToken, remaining, field};</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="fc">&nbsp;        if (this == o) {</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="pc">&nbsp;        if (o instanceof Schema) {</b>
<b class="fc">&nbsp;            Schema schema = (Schema) o;</b>
<b class="pc">&nbsp;            return schema.canEqual(this) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(title, schema.title) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(defaultValue, schema.defaultValue) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(description, schema.description) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(id, schema.id) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(nullable, schema.nullable) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(readOnly, schema.readOnly) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(writeOnly, schema.writeOnly) &amp;&amp;</b>
<b class="pc">&nbsp;                    Objects.equals(unprocessedProperties, schema.unprocessedProperties);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="fc">&nbsp;        return Objects.hash(title, description, id, defaultValue, nullable, readOnly, writeOnly, unprocessedProperties);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getTitle() {
<b class="fc">&nbsp;        return title;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getDescription() {
<b class="fc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getId() {
<b class="fc">&nbsp;        return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getSchemaLocation() {
<b class="fc">&nbsp;        return schemaLocation;</b>
&nbsp;    }
&nbsp;
&nbsp;    public SchemaLocation getLocation() {
<b class="fc">&nbsp;        return location;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Object getDefaultValue() {
<b class="fc">&nbsp;        return this.defaultValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasDefaultValue() {
<b class="fc">&nbsp;        return this.defaultValue != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Boolean isNullable() {
<b class="fc">&nbsp;        return nullable;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Boolean isReadOnly() {
<b class="fc">&nbsp;        return readOnly;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Boolean isWriteOnly() {
<b class="fc">&nbsp;        return writeOnly;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the properties of the original schema JSON which aren&#39;t keywords of json schema
&nbsp;     * (therefore they weren&#39;t recognized during schema loading).
&nbsp;     */
&nbsp;    public Map&lt;String, Object&gt; getUnprocessedProperties() {
<b class="fc">&nbsp;        return unmodifiableMap(unprocessedProperties);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Describes the instance as a JSONObject to {@code writer}.
&nbsp;     * &lt;p&gt;
&nbsp;     * First it adds the {@code &quot;title} , {@code &quot;description&quot;} and {@code &quot;id&quot;} properties then calls
&nbsp;     * {@link #describePropertiesTo(JSONPrinter)}, which will add the subclass-specific properties.
&nbsp;     * &lt;p&gt;
&nbsp;     * It is used by {@link #toString()} to serialize the schema instance into its JSON representation.
&nbsp;     *
&nbsp;     * @param writer
&nbsp;     *         it will receive the schema description
&nbsp;     */
&nbsp;    public void describeTo(JSONPrinter writer) {
<b class="fc">&nbsp;        accept(new ToStringVisitor(writer));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Subclasses are supposed to override this method to describe the subclass-specific attributes.
&nbsp;     * This method is called by {@link #describeTo(JSONPrinter)} after adding the generic properties if
&nbsp;     * they are present ({@code id}, {@code title} and {@code description}). As a side effect,
&nbsp;     * overriding subclasses don&#39;t have to open and close the object with {@link JSONWriter#object()}
&nbsp;     * and {@link JSONWriter#endObject()}.
&nbsp;     *
&nbsp;     * @param writer
&nbsp;     *         it will receive the schema description
&nbsp;     */
&nbsp;    void describePropertiesTo(JSONPrinter writer) {
&nbsp;
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    abstract void accept(Visitor visitor);
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="fc">&nbsp;        StringWriter w = new StringWriter();</b>
<b class="fc">&nbsp;        JSONPrinter writer = new JSONPrinter(w);</b>
<b class="fc">&nbsp;        new ToStringVisitor(writer).visit(this);</b>
<b class="fc">&nbsp;        return w.getBuffer().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated
&nbsp;    protected ValidationException failure(String message, String keyword) {
<b class="nc">&nbsp;        return new ValidationException(this, message, keyword, schemaLocation.toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated
&nbsp;    protected ValidationException failure(Class&lt;?&gt; expectedType, Object actualValue) {
<b class="nc">&nbsp;        return new ValidationException(this, expectedType, actualValue, &quot;type&quot;, schemaLocation.toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Since we add state in subclasses, but want those subclasses to be non final, this allows us to
&nbsp;     * have equals methods that satisfy the equals contract.
&nbsp;     * &lt;p&gt;
&nbsp;     * http://www.artima.com/lejava/articles/equality.html
&nbsp;     *
&nbsp;     * @param other
&nbsp;     *         the subject of comparison
&nbsp;     * @return {@code true } if {@code this} can be equal to {@code other}
&nbsp;     */
&nbsp;    protected boolean canEqual(Object other) {
<b class="nc">&nbsp;        return (other instanceof Schema);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-01 17:31</div>
</div>
</body>
</html>
